{% extends 'base.html' %}

{% block content %}

<style>
    /* –ï—Ñ–µ–∫—Ç –ø—ñ–¥–Ω—è—Ç—Ç—è –∫–∞—Ä—Ç–∫–∏ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–Ω—ñ */
    .hover-lift {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .hover-lift:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 20px rgba(0,0,0,0.08) !important;
        border-color: var(--bs-primary) !important;
    }

    /* –°—Ç–∏–ª—å –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —ñ–∫–æ–Ω–∫–∏ */
    .icon-square {
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        font-size: 1.5rem;
        flex-shrink: 0;
    }

    /* –§–æ–Ω–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è —ñ–∫–æ–Ω–æ–∫ */
    .bg-blue-subtle { background-color: rgba(13, 110, 253, 0.1); color: #0d6efd; }
    .bg-purple-subtle { background-color: rgba(111, 66, 193, 0.1); color: #6f42c1; }
    .bg-green-subtle { background-color: rgba(25, 135, 84, 0.1); color: #198754; }
    .bg-orange-subtle { background-color: rgba(253, 126, 20, 0.1); color: #fd7e14; }
    .bg-teal-subtle { background-color: rgba(32, 201, 151, 0.1); color: #20c997; }
    .bg-gray-subtle { background-color: #e9ecef; color: #495057; }

    /* –°—Ç–∏–ª—å –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö —Ü–∏—Ñ—Ä */
    .stat-value {
        font-size: 1.75rem;
        font-weight: 700;
        color: #343a40;
        line-height: 1.2;
    }
    .stat-label {
        font-size: 0.85rem;
        color: #6c757d;
        font-weight: 500;
    }
</style>

<div class="py-4">
    <div class="row mb-4 align-items-center">
        <div class="col">
            <h2 class="fw-bold text-dark mb-1">–°–∏—Å—Ç–µ–º–∞ –æ–±–ª—ñ–∫—É –∞–∫—Ç–∏–≤—ñ–≤</h2>
            <p class="text-muted mb-0">–ö–µ—Ä—É–≤–∞–Ω–Ω—è –º–∞–π–Ω–æ–º —Ç–∞ —Å–µ—Ä–≤—ñ—Å–Ω–∏–º –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è–º</p>
        </div>
        <div class="col-auto">
            <span class="text-muted small">{% now "d.m.Y" %}</span>
        </div>
    </div>

    <div class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4">

        <div class="col">
            <div class="card h-100 border-0 shadow-sm hover-lift position-relative">
                <div class="card-body p-4">
                    <div class="d-flex align-items-center mb-3">
                        <div class="icon-square bg-blue-subtle me-3">
                            <i class="bi bi-pc-display"></i>
                        </div>
                        <div>
                            <h5 class="card-title fw-bold mb-0">–ú–∞–π–Ω–æ</h5>
                            <span class="text-muted small">–û–±–ª—ñ–∫ —Ç–µ—Ö–Ω—ñ–∫–∏</span>
                        </div>
                    </div>

                    <div class="mt-3">
                        <div class="stat-value">{{ assets_count }}</div>
                        <div class="stat-label">–æ–¥–∏–Ω–∏—Ü—å –Ω–∞ –æ–±–ª—ñ–∫—É</div>
                    </div>

                    <a href="/inventory/" class="stretched-link"></a>
                </div>
            </div>
        </div>

        <div class="col">
            <div class="card h-100 border-0 shadow-sm hover-lift position-relative">
                <div class="card-body p-4">
                    <div class="d-flex align-items-center mb-3">
                        <div class="icon-square bg-orange-subtle me-3">
                            <i class="bi bi-tools"></i>
                        </div>
                        <div>
                            <h5 class="card-title fw-bold mb-0">–°–µ—Ä–≤—ñ—Å</h5>
                            <span class="text-muted small">–†–µ–º–æ–Ω—Ç —Ç–∞ –∫–∞—Ä—Ç—Ä–∏–¥–∂—ñ</span>
                        </div>
                    </div>

                    <div class="d-flex justify-content-between mt-3 text-center">
                        <div>
                            <div class="fw-bold fs-5 {% if waiting_for_repair > 0 %}text-danger{% else %}text-dark{% endif %}">
                                {{ waiting_for_repair }}
                            </div>
                            <small class="text-muted" style="font-size: 0.7rem; display: block; line-height: 1.1;">–û—á—ñ–∫—É—é—Ç—å</small>
                        </div>
                        <div class="vr bg-secondary opacity-25"></div>
                        <div>
                            <div class="fw-bold fs-5 text-primary">
                                {{ in_repair_process }}
                            </div>
                            <small class="text-muted" style="font-size: 0.7rem; display: block; line-height: 1.1;">–í —Ä–æ–±–æ—Ç—ñ</small>
                        </div>
                        <div class="vr bg-secondary opacity-25"></div>
                        <div>
                            <div class="fw-bold fs-5 text-success">
                                {{ ready_on_stock }}
                            </div>
                            <small class="text-muted" style="font-size: 0.7rem; display: block; line-height: 1.1;">–°–∫–ª–∞–¥</small>
                        </div>
                    </div>

                    <a href="/service/" class="stretched-link"></a>
                </div>
            </div>
        </div>

        <div class="col">
            <div class="card h-100 border-0 shadow-sm hover-lift position-relative">
                <div class="card-body p-4">
                    <div class="d-flex align-items-center mb-3">
                        <div class="icon-square bg-purple-subtle me-3">
                            <i class="bi bi-people-fill"></i>
                        </div>
                        <div>
                            <h5 class="card-title fw-bold mb-0">–ü–µ—Ä—Å–æ–Ω–∞–ª</h5>
                            <span class="text-muted small">–®—Ç–∞—Ç–Ω–∏–π —Ä–æ–∑–ø–∏—Å</span>
                        </div>
                    </div>

                    <div class="mt-3">
                        <div class="stat-value">{{ employees_count }}</div>
                        <div class="stat-label">–ø—Ä–∞—Ü—ñ–≤–Ω–∏–∫—ñ–≤</div>
                    </div>

                    <a href="{% url 'staff_list' %}" class="stretched-link"></a>
                </div>
            </div>
        </div>

        <div class="col">
            <div class="card h-100 border-0 shadow-sm hover-lift position-relative">
                <div class="card-body p-4 d-flex align-items-center">
                    <div class="icon-square bg-gray-subtle me-3">
                        <i class="bi bi-archive"></i>
                    </div>
                    <div>
                        <h6 class="card-title fw-bold mb-1">–ê—Ä—Ö—ñ–≤ –∞–∫—Ç—ñ–≤</h6>
                        <p class="text-muted small mb-0">–Ü—Å—Ç–æ—Ä—ñ—è –ø–µ—Ä–µ–¥–∞—á—ñ —Ç–µ—Ö–Ω—ñ–∫–∏</p>
                    </div>
                    <a href="/service/reports/" class="stretched-link"></a>
                    <i class="bi bi-chevron-right ms-auto text-muted small"></i>
                </div>
            </div>
        </div>

        <div class="col">
            <div class="card h-100 border-0 shadow-sm hover-lift position-relative">
                <div class="card-body p-4 d-flex align-items-center">
                    <div class="icon-square bg-teal-subtle me-3">
                        <i class="bi bi-journal-bookmark-fill"></i>
                    </div>
                    <div>
                        <h6 class="card-title fw-bold mb-1">–î–æ–≤—ñ–¥–Ω–∏–∫</h6>
                        <p class="text-muted small mb-0">–ö–æ–Ω—Ç–∞–∫—Ç–∏ —Ç–∞ –≤—ñ–¥–¥—ñ–ª–∏</p>
                    </div>
                    <a href="{% url 'directory_list' %}" class="stretched-link"></a>
                    <i class="bi bi-chevron-right ms-auto text-muted small"></i>
                </div>
            </div>
        </div>

        <div class="col">
            <div class="card h-100 border-0 shadow-sm hover-lift position-relative">
                <div class="card-body p-4 d-flex align-items-center">
                    <div class="icon-square bg-green-subtle me-3">
                        <i class="bi bi-folder2-open"></i>
                    </div>
                    <div>
                        <h6 class="card-title fw-bold mb-1">–§–∞–π–ª–∏</h6>
                        <p class="text-muted small mb-0">–Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó —Ç–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∏</p>
                    </div>
                    <a href="/docs/" class="stretched-link"></a>
                    <i class="bi bi-chevron-right ms-auto text-muted small"></i>
                </div>
            </div>
        </div>

    </div>
</div>
<!--–°–µ–∫—Ä–µ—Ç–Ω–∞ –≥—Ä–∞ -->
<style>
    /* --- –ë–ê–ó–ê --- */
    #secret-match3-wrapper { font-family: 'Segoe UI', sans-serif; line-height: 1.5; }
    #secret-match3-wrapper * { box-sizing: border-box; margin: 0; padding: 0; }

    #secret-match3-wrapper .m3g-overlay {
        display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0, 0, 0, 0.95); z-index: 2147483647;
        justify-content: center; align-items: center;
        backdrop-filter: blur(8px);
    }

    #secret-match3-wrapper .m3g-container {
        background: #181818; padding: 25px; border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0,0,0,0.9), 0 0 0 1px #333;
        text-align: center; color: white; position: relative;
        max-width: 95vw;
    }

    #secret-match3-wrapper .m3g-header {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 20px; padding: 0 10px;
    }

    #secret-match3-wrapper .m3g-stats {
        font-size: 1.5rem; font-weight: bold; color: #ffcc00;
        display: flex; gap: 40px; justify-content: center; margin-bottom: 20px;
        text-shadow: 0 2px 10px rgba(255, 204, 0, 0.3);
    }

    #secret-match3-wrapper .m3g-grid-container {
        position: relative;
        background-color: #252525;
        padding: 10px; border-radius: 15px;
        border: 4px solid #3a3a3a;
        margin: 0 auto;
        box-shadow: inset 0 0 30px rgba(0,0,0,0.8);
    }

    /* --- –ö–õ–Ü–¢–ò–ù–ö–ê --- */
    #secret-match3-wrapper .m3g-cell {
        position: absolute;
        width: 50px; height: 50px;
        background-color: #353535;
        border-radius: 12px;
        display: flex; justify-content: center; align-items: center;
        font-size: 32px; cursor: pointer; user-select: none;
        transition: transform 0.15s ease-out, top 0.2s cubic-bezier(0.5, 0, 0.5, 1);
        z-index: 10;
        box-shadow: inset 0 -3px 0 rgba(0,0,0,0.4);
        overflow: hidden;
    }

    #secret-match3-wrapper .m3g-cell.selected {
        filter: brightness(1.3);
        transform: scale(1.1);
        background-color: #505050;
        box-shadow: 0 0 0 3px #ffcc00;
        z-index: 20;
    }

    /* –ê–ö–¢–ò–í–ù–ê –í–ï–°–ï–õ–ö–ê (–í–∏–±—ñ—Ä —Ü—ñ–ª—ñ) */
    #secret-match3-wrapper .m3g-cell.active-bonus {
        transform: scale(1.2);
        box-shadow: 0 0 0 3px #fff, 0 0 30px #ff00de;
        z-index: 100;
        animation: activePulse 0.5s infinite alternate;
    }
    @keyframes activePulse { from { filter: brightness(1); } to { filter: brightness(1.4); } }
    #secret-match3-wrapper .m3g-cell.new-spawn { animation: popIn 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

    /* --- –ë–û–ù–£–°–ò: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ --- */
    .m3g-bonus-bg {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 1;
    }
    .m3g-bonus-icon {
        position: relative; z-index: 2;
        width: 100%; height: 100%;
        display: flex; justify-content: center; align-items: center; /* Flexbox —Ü–µ–Ω—Ç—Ä—É–≤–∞–Ω–Ω—è */
        padding-top: 3px;
        color: white;
        text-shadow: 0 2px 4px rgba(0,0,0,0.6);
        line-height: 0;
    }

    /* --- –°–¢–ò–õ–Ü –ë–û–ù–£–°–Ü–í --- */

    /* –°–¢–†–Ü–õ–ö–ò */
    .bonus-row .m3g-bonus-bg, .bonus-col .m3g-bonus-bg {
        background: linear-gradient(135deg, #007bff, #00d4ff);
        animation: arrowPulseBg 1s infinite alternate;
    }
    /* –ë–ª—ñ–∫ */
    .bonus-row .m3g-bonus-bg::after, .bonus-col .m3g-bonus-bg::after {
        content: ''; position: absolute; top: 0; left: -150%; width: 100%; height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
        transform: skewX(-25deg);
        animation: arrowShine 1.5s infinite;
    }

    .bonus-row .m3g-bonus-icon { font-size: 34px; font-weight: 900; }
    .bonus-col .m3g-bonus-icon { font-size: 34px; font-weight: 900; }

    /* –ë–û–ú–ë–ê */
    .bonus-bomb .m3g-bonus-bg {
        background: radial-gradient(circle, #ff3333, #660000);
        animation: bombPanic 0.5s infinite alternate;
    }
    .bonus-bomb .m3g-bonus-icon {
        font-size: 28px;
        animation: bombShake 0.2s infinite;
    }

    /* –í–ï–°–ï–õ–ö–ê */
    .bonus-rainbow .m3g-bonus-bg {
        background: conic-gradient(#ff0000, #ff9900, #ffff00, #33ff00, #0099ff, #6633ff, #ff0000);
        animation: rainbowSpin 2s linear infinite;
    }
    .bonus-rainbow .m3g-bonus-icon {
        font-size: 32px;
        text-shadow: 0 0 10px rgba(255,255,255,0.8);
    }

    /* –ê–Ω—ñ–º–∞—Ü—ñ—ó */
    @keyframes arrowPulseBg { from { filter: brightness(1); } to { filter: brightness(1.3); } }
    @keyframes arrowShine { 0% { left: -150%; } 40% { left: 150%; } 100% { left: 150%; } }

    @keyframes bombPanic { from { transform: scale(1); box-shadow: inset 0 0 10px #000; } to { transform: scale(1.05); box-shadow: inset 0 0 20px #ff0000; } }
    @keyframes bombShake { 0% { transform: translate(0, 0) rotate(0deg); } 25% { transform: translate(-1px, 1px) rotate(-2deg); } 50% { transform: translate(1px, -1px) rotate(2deg); } 75% { transform: translate(-1px, -1px) rotate(-1deg); } 100% { transform: translate(0, 0) rotate(0deg); } }

    @keyframes rainbowSpin { from { transform: scale(1.4) rotate(0deg); } to { transform: scale(1.4) rotate(360deg); } }

    #secret-match3-wrapper .m3g-close-btn { background: none; border: none; color: #666; font-size: 32px; cursor: pointer; transition: color 0.2s;}
    #secret-match3-wrapper .m3g-close-btn:hover { color: #ff5555; }

    #m3g-msg { height: 24px; color: #ff6b6b; font-weight: bold; font-size: 0.9rem; margin-top: 5px; min-width: 200px; }
</style>

<div id="secret-match3-wrapper">
    <div class="m3g-overlay" id="m3g-overlay">
        <div class="m3g-container">
            <div class="m3g-header">
                <h2 style="margin:0; text-transform:uppercase; letter-spacing:2px; font-weight:900;">–¢—Ä–∏ –≤ —Ä—è–¥</h2>
                <button class="m3g-close-btn" id="m3g-close">√ó</button>
            </div>
            <div class="m3g-stats">
                <div>üéØ <span id="m3g-score">0</span> / 400</div>
                <div>‚è≥ <span id="m3g-timer">120</span>s</div>
            </div>
            <div class="m3g-grid-container" id="m3g-grid"></div>
            <div id="m3g-msg"></div>
        </div>
    </div>
</div>

<script>
(function() {
    // --- –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø ---
    const TARGET_SCORE = 400;
    const INITIAL_TIME = 120;
    const COLS = 8;
    const ROWS = 8;
    const CELL_SIZE = 50;
    const GAP = 6;
    const COLORS = ['üçé', 'üçä', 'üçá', 'ü••', 'ü•ù', 'üç™'];
    const SECRET_CODES = ['—á—É–¥–æ', 'xelj'];

    // --- –°–¢–ê–ù ---
    let grid = [];
    let score = 0;
    let timeLeft = INITIAL_TIME;
    let timerId = null;
    let isBusy = false;
    let selectedCell = null;
    let activeRainbow = null;
    let inputBuffer = '';
    let lastSwappedPair = [];

    // DOM
    const overlay = document.getElementById('m3g-overlay');
    const gridEl = document.getElementById('m3g-grid');
    const scoreEl = document.getElementById('m3g-score');
    const timerEl = document.getElementById('m3g-timer');
    const msgEl = document.getElementById('m3g-msg');

    // --- GAME ENGINE ---
    function init() {
        const w = COLS * CELL_SIZE + (COLS - 1) * GAP + 20;
        const h = ROWS * CELL_SIZE + (ROWS - 1) * GAP + 20;
        gridEl.style.width = w + 'px';
        gridEl.style.height = h + 'px';
        document.addEventListener('keydown', handleKeyInput);
        document.getElementById('m3g-close').addEventListener('click', closeGame);
    }

    function handleKeyInput(e) {
        inputBuffer += e.key;
        if (inputBuffer.length > 10) inputBuffer = inputBuffer.slice(-10);
        if (SECRET_CODES.some(code => inputBuffer.toLowerCase().endsWith(code))) {
            openGame();
            inputBuffer = '';
        }
    }

    function openGame() { overlay.style.display = 'flex'; startGame(); }
    function closeGame() { overlay.style.display = 'none'; stopGame(); }
    function stopGame() { clearInterval(timerId); gridEl.innerHTML = ''; grid = []; }

    function startGame() {
        stopGame();
        score = 0; timeLeft = INITIAL_TIME; isBusy = false;
        selectedCell = null; activeRainbow = null;
        updateUI(); msgEl.innerText = ""; lastSwappedPair = [];

        do { createGridData(); } while (findMatches().matched.length > 0);
        renderGrid();

        timerId = setInterval(() => {
            timeLeft--; updateUI();
            if (timeLeft <= 0) endGame(false);
        }, 1000);
    }

    function updateUI() {
        scoreEl.innerText = score;
        timerEl.innerText = timeLeft;
        if(score >= TARGET_SCORE) scoreEl.style.color = '#00ff00';
        else scoreEl.style.color = '#ffcc00';
    }

    function createGridData() {
        grid = []; gridEl.innerHTML = '';
        for (let r = 0; r < ROWS; r++) {
            let row = [];
            for (let c = 0; c < COLS; c++) {
                const type = COLORS[Math.floor(Math.random() * COLORS.length)];
                row.push({ r, c, type, bonus: null, el: createCellEl(r, c, type) });
            }
            grid.push(row);
        }
    }

    function createCellEl(r, c, type) {
        const el = document.createElement('div');
        el.classList.add('m3g-cell');
        el.innerText = type;
        el.style.left = (c * (CELL_SIZE + GAP)) + 'px';
        el.style.top = (r * (CELL_SIZE + GAP)) + 'px';
        el.onclick = () => handleCellClick(r, c);
        gridEl.appendChild(el);
        return el;
    }

    // --- –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–Ø ---
    function updateCellVisuals(cell) {
        cell.el.classList.remove('bonus-row', 'bonus-col', 'bonus-bomb', 'bonus-rainbow');

        if (cell.bonus) {
            let icon = '';
            let className = '';

            if (cell.bonus === 'row') { icon = '‚Üî'; className = 'bonus-row'; }
            else if (cell.bonus === 'col') { icon = '‚Üï'; className = 'bonus-col'; }
            else if (cell.bonus === 'bomb') { icon = 'üí£'; className = 'bonus-bomb'; }
            else if (cell.bonus === 'rainbow') { icon = '‚ú®'; className = 'bonus-rainbow'; }

            cell.el.classList.add(className);
            cell.el.innerHTML = `<div class="m3g-bonus-bg"></div><div class="m3g-bonus-icon">${icon}</div>`;
        } else {
            cell.el.innerHTML = cell.type;
        }
    }

    function renderGrid() {
        grid.forEach(row => {
            row.forEach(cell => {
                if (!cell) return;
                cell.el.style.left = (cell.c * (CELL_SIZE + GAP)) + 'px';
                cell.el.style.top = (cell.r * (CELL_SIZE + GAP)) + 'px';

                updateCellVisuals(cell);

                cell.el.onclick = () => handleCellClick(cell.r, cell.c);
                cell.el.classList.remove('selected', 'active-bonus');

                if (selectedCell === cell) cell.el.classList.add('selected');
                if (activeRainbow === cell) cell.el.classList.add('active-bonus');
            });
        });
    }

    // --- –õ–û–ì–Ü–ö–ê ---
    async function handleCellClick(r, c) {
        if (isBusy || timeLeft <= 0 || !grid[r][c]) return;
        const clicked = grid[r][c];
        msgEl.innerText = "";

        if (activeRainbow) {
            if (clicked === activeRainbow) {
                activeRainbow = null; renderGrid(); return;
            }
            if (clicked.bonus) {
                activeRainbow = null; renderGrid();
            } else {
                isBusy = true;
                activeRainbow.el.classList.remove('active-bonus');

                // –Ø–∫—â–æ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –∑–≤–∏—á–∞–π–Ω–∏–π —Ñ—Ä—É–∫—Ç - –∫–æ–ª—ñ—Ä –±–µ—Ä–µ–º–æ –∑ –Ω—å–æ–≥–æ
                // –Ø–∫—â–æ —Ü–µ –±–æ–Ω—É—Å (–∞–ª–µ –º–∏ –¥–æ–º–æ–≤–∏–ª–∏—Å—å —â–æ –±–æ–Ω—É—Å–∏ –Ω–µ –∫–ª—ñ–∫–∞–±–µ–ª—å–Ω—ñ –¥–ª—è –≤–µ—Å–µ–ª–∫–∏)
                // –ê–ª–µ –ø—Ä–æ –≤—Å—è–∫ –≤–∏–ø–∞–¥–æ–∫ - –≤–µ—Å–µ–ª–∫–∞ –Ω–µ —Å–ø–∞–ª—é—î –±–æ–Ω—É—Å–∏
                if (!clicked.bonus) {
                    let targetColor = clicked.type;
                    await explodeColor(targetColor, activeRainbow);
                }

                activeRainbow = null; selectedCell = null;
                await applyGravity();
                isBusy = false;
                return;
            }
        }

        if (clicked.bonus === 'rainbow') {
            activeRainbow = clicked;
            selectedCell = null;
            msgEl.innerText = "–û–±–µ—Ä—ñ—Ç—å –∫–æ–ª—ñ—Ä!";
            renderGrid();
            return;
        }

        if (clicked.bonus) {
            isBusy = true;
            clicked.el.style.transform = "scale(1.2)";
            await wait(100);

            let targets = new Set();
            activateBonusEffect(r, c, clicked.bonus, targets);

            // –°–∞–º –±–æ–Ω—É—Å —Ç–µ–∂ –∑–Ω–∏–∫–∞—î
            targets.add(`${r},${c}`);

            let destroyedCount = targets.size;
            score += destroyedCount * 2;
            updateUI();

            await destroyTargets(targets);
            selectedCell = null;
            renderGrid();
            await applyGravity();
            isBusy = false;
            return;
        }

        if (!selectedCell) {
            selectedCell = clicked;
            renderGrid();
        } else {
            const first = selectedCell;
            selectedCell = null;
            renderGrid();

            if (first === clicked) return;

            const isAdj = Math.abs(first.r - clicked.r) + Math.abs(first.c - clicked.c) === 1;
            if (isAdj) {
                await swap(first, clicked);
            } else {
                selectedCell = clicked;
                renderGrid();
            }
        }
    }

    async function swap(cellA, cellB) {
        isBusy = true;
        lastSwappedPair = [cellA, cellB];

        const tempType = cellA.type; const tempBonus = cellA.bonus;
        cellA.type = cellB.type; cellA.bonus = cellB.bonus;
        cellB.type = tempType; cellB.bonus = tempBonus;

        const ax = cellA.c * (CELL_SIZE + GAP); const ay = cellA.r * (CELL_SIZE + GAP);
        const bx = cellB.c * (CELL_SIZE + GAP); const by = cellB.r * (CELL_SIZE + GAP);

        cellA.el.style.transform = `translate(${bx - ax}px, ${by - ay}px)`;
        cellB.el.style.transform = `translate(${ax - bx}px, ${ay - by}px)`;

        await wait(150);
        cellA.el.style.transform = ''; cellB.el.style.transform = '';
        renderGrid();

        const matches = findMatches(lastSwappedPair);
        if (matches.matched.length > 0) {
            await processMatches(matches);
        } else {
            msgEl.innerText = "–•—ñ–¥ –Ω–µ–º–æ–∂–ª–∏–≤–∏–π";
            const tT = cellA.type; const tB = cellA.bonus;
            cellA.type = cellB.type; cellA.bonus = cellB.bonus;
            cellB.type = tT; cellB.bonus = tB;

            cellA.el.style.transition = 'transform 0.15s'; cellB.el.style.transition = 'transform 0.15s';
            cellA.el.style.transform = `translate(${bx - ax}px, ${by - ay}px)`;
            cellB.el.style.transform = `translate(${ax - bx}px, ${ay - by}px)`;

            await wait(20);
            cellA.el.style.transform = ''; cellB.el.style.transform = '';
            await wait(150);
            renderGrid();
        }
        lastSwappedPair = [];
        isBusy = false;
    }

    function findMatches(priorityCells = []) {
        let matchedSet = new Set();
        let bonuses = [];

        const isPriority = (r, c) => priorityCells.some(cell => cell.r === r && cell.c === c);

        // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS - 2; c++) {
                // –Ü–ì–ù–û–†–£–Ñ–ú–û –ë–û–ù–£–°–ò –£ –ó–ë–Ü–ì–ê–•
                if (!grid[r][c] || grid[r][c].bonus) continue;

                let matchLen = 1;
                while (c + matchLen < COLS &&
                       grid[r][c + matchLen] &&
                       !grid[r][c + matchLen].bonus &&
                       grid[r][c].type === grid[r][c + matchLen].type) {
                    matchLen++;
                }

                if (matchLen >= 3) {
                    let bType = null;
                    if (matchLen >= 5) bType = 'rainbow';
                    else if (matchLen === 4) bType = 'row';

                    let spawnR = r, spawnC = c + Math.floor(matchLen / 2);
                    if (bType) {
                        for(let k=0; k<matchLen; k++) if (isPriority(r, c + k)) { spawnC = c + k; break; }
                        bonuses.push({ r: spawnR, c: spawnC, type: bType });
                    }
                    for(let k=0; k<matchLen; k++) matchedSet.add(`${r},${c+k}`);
                    c += matchLen - 1;
                }
            }
        }

        // –í–µ—Ä—Ç–∏–∫–∞–ª—å
        for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS - 2; r++) {
                if (!grid[r][c] || grid[r][c].bonus) continue;

                let matchLen = 1;
                while (r + matchLen < ROWS &&
                       grid[r + matchLen][c] &&
                       !grid[r + matchLen][c].bonus &&
                       grid[r][c].type === grid[r + matchLen][c].type) {
                    matchLen++;
                }

                if (matchLen >= 3) {
                    let bType = null;
                    if (matchLen >= 5) bType = 'rainbow';
                    else if (matchLen === 4) bType = 'col';

                    let spawnR = r + Math.floor(matchLen / 2), spawnC = c;
                    let existingBonus = bonuses.find(b => b.r === spawnR && b.c === spawnC);

                    if (bType) {
                        for(let k=0; k<matchLen; k++) if (isPriority(r + k, c)) { spawnR = r + k; break; }
                        if (bType === 'rainbow') {
                            bonuses = bonuses.filter(b => !(b.r === spawnR && b.c === spawnC));
                            bonuses.push({ r: spawnR, c: spawnC, type: 'rainbow' });
                        } else if (!existingBonus) {
                             bonuses.push({ r: spawnR, c: spawnC, type: bType });
                        }
                    }
                    for(let k=0; k<matchLen; k++) matchedSet.add(`${r+k},${c}`);
                    r += matchLen - 1;
                }
            }
        }

        // –ö–≤–∞–¥—Ä–∞—Ç–∏
        for (let r = 0; r < ROWS - 1; r++) {
            for (let c = 0; c < COLS - 1; c++) {
                if (!grid[r][c] || !grid[r+1][c] || !grid[r][c+1] || !grid[r+1][c+1]) continue;
                // –Ü–≥–Ω–æ—Ä—É—î–º–æ –±–æ–Ω—É—Å–∏
                if (grid[r][c].bonus || grid[r+1][c].bonus || grid[r][c+1].bonus || grid[r+1][c+1].bonus) continue;

                let t = grid[r][c].type;
                if (t === grid[r+1][c].type && t === grid[r][c+1].type && t === grid[r+1][c+1].type) {
                    matchedSet.add(`${r},${c}`); matchedSet.add(`${r+1},${c}`);
                    matchedSet.add(`${r},${c+1}`); matchedSet.add(`${r+1},${c+1}`);

                    let conflict = bonuses.find(b => (b.r >= r && b.r <= r+1 && b.c >= c && b.c <= c+1 && b.type === 'rainbow'));
                    if (!conflict) {
                         let bonusPos = {r, c};
                         if (isPriority(r, c)) bonusPos = {r, c};
                         else if (isPriority(r+1, c)) bonusPos = {r: r+1, c: c};
                         else if (isPriority(r, c+1)) bonusPos = {r: r, c: c+1};
                         else if (isPriority(r+1, c+1)) bonusPos = {r: r+1, c: c+1};

                         bonuses = bonuses.filter(b => !(b.r === bonusPos.r && b.c === bonusPos.c));
                         bonuses.push({ r: bonusPos.r, c: bonusPos.c, type: 'bomb' });
                    }
                }
            }
        }

        return { matched: Array.from(matchedSet), bonuses };
    }

    async function processMatches(matchData) {
        const { matched, bonuses } = matchData;

        score += matched.length * 1;
        score += bonuses.length * 10;
        updateUI();

        let allTargets = new Set(matched);

        matched.forEach(key => {
            let [r, c] = key.split(',').map(Number);
            let cell = grid[r][c];
            if (cell && cell.bonus) {
                activateBonusEffect(r, c, cell.bonus, allTargets);
            }
        });

        await destroyTargets(allTargets);

        bonuses.forEach(b => {
            if (!grid[b.r][b.c]) {
                let type = COLORS[Math.floor(Math.random() * COLORS.length)];
                let el = createCellEl(b.r, b.c, type);

                // –°–¢–í–û–†–ï–ù–ù–Ø –ë–û–ù–£–°–ê (–¢–ò–ü –ó–ú–Ü–ù–Æ–Ñ–¢–¨–°–Ø –ù–ê –ù–ï–ô–¢–†–ê–õ–¨–ù–ò–ô)
                grid[b.r][b.c] = { r: b.r, c: b.c, type: 'BONUS_ENTITY', bonus: b.type, el };
                updateCellVisuals(grid[b.r][b.c]);
                el.classList.add('new-spawn');
            } else {
                grid[b.r][b.c].bonus = b.type;
                grid[b.r][b.c].type = 'BONUS_ENTITY'; // –í–∏–¥–∞–ª—è—î–º–æ —Ñ—Ä—É–∫—Ç –∑-–ø—ñ–¥ –∫–∞–ø–æ—Ç—É
                updateCellVisuals(grid[b.r][b.c]);
            }
        });

        await applyGravity();
    }

    async function destroyTargets(targetSet) {
        targetSet.forEach(key => {
            let [r, c] = key.split(',').map(Number);
            if(grid[r][c]) {
                grid[r][c].el.style.transform = 'scale(0)';
                grid[r][c].el.style.opacity = '0';
            }
        });
        await wait(150);
        targetSet.forEach(key => {
            let [r, c] = key.split(',').map(Number);
            if(grid[r][c]) { grid[r][c].el.remove(); grid[r][c] = null; }
        });
    }

    function activateBonusEffect(r, c, type, targetSet) {
        // –î–û–î–ê–¢–ö–û–í–ê –ü–ï–†–ï–í–Ü–†–ö–ê: –ë–û–ù–£–°–ò –ù–ï –°–ü–ê–õ–Æ–Æ–¢–¨ –Ü–ù–®–Ü –ë–û–ù–£–°–ò
        const safeAdd = (tr, tc) => {
            if (tr >= 0 && tr < ROWS && tc >= 0 && tc < COLS) {
                // –Ø–∫—â–æ —Ü–µ –Ω–µ –ø–æ—Ç–æ—á–Ω–∏–π –±–æ–Ω—É—Å (—Å–∞–º–æ–∑–Ω–∏—â–µ–Ω–Ω—è) —ñ —Ü–µ –∫–ª—ñ—Ç–∏–Ω–∫–∞ –∑ —ñ–Ω—à–∏–º –±–æ–Ω—É—Å–æ–º - –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
                if ((tr !== r || tc !== c) && grid[tr][tc] && grid[tr][tc].bonus) return;
                targetSet.add(`${tr},${tc}`);
            }
        };

        if (type === 'row') for(let i=0; i<COLS; i++) safeAdd(r, i);
        if (type === 'col') for(let i=0; i<ROWS; i++) safeAdd(i, c);
        if (type === 'bomb') {
            for(let i=r-1; i<=r+1; i++)
                for(let j=c-1; j<=c+1; j++) safeAdd(i, j);
        }
    }

    async function applyGravity() {
        let moves = false;
        for (let c = 0; c < COLS; c++) {
            let emptyCount = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (grid[r][c] === null) {
                    emptyCount++;
                } else if (emptyCount > 0) {
                    let cell = grid[r][c];
                    grid[r + emptyCount][c] = cell;
                    grid[r][c] = null;
                    cell.r += emptyCount;
                    cell.el.style.top = (cell.r * (CELL_SIZE + GAP)) + 'px';
                    moves = true;
                }
            }
            for (let r = 0; r < emptyCount; r++) {
                let type = COLORS[Math.floor(Math.random() * COLORS.length)];
                let el = createCellEl(r - emptyCount, c, type);
                grid[r][c] = { r, c, type, bonus: null, el };
                void el.offsetWidth;
                el.style.top = (r * (CELL_SIZE + GAP)) + 'px';
            }
        }

        await wait(200);
        renderGrid();

        const newMatches = findMatches();
        if (newMatches.matched.length > 0) {
            await processMatches(newMatches);
        } else {
            if (!hasPossibleMoves()) {
                msgEl.innerText = "–ü–ï–†–ï–ú–Ü–®–£–Æ...";
                await wait(500);
                shuffleBoard();
            }
            if (score >= TARGET_SCORE) endGame(true);
        }
    }

    async function explodeColor(type, rainbowCell) {
        let targets = [];
        for(let r=0; r<ROWS; r++)
            for(let c=0; c<COLS; c++) {
                // –í–ï–°–ï–õ–ö–ê –ù–ï –ß–Ü–ü–ê–Ñ –ë–û–ù–£–°–ò
                if(grid[r][c] && !grid[r][c].bonus && grid[r][c].type === type) {
                    targets.push(grid[r][c]);
                }
            }

        targets.forEach(c => {
            c.el.style.transition = 'all 0.2s';
            c.el.style.transform = 'scale(0) rotate(180deg)';
        });
        if(rainbowCell) rainbowCell.el.style.transform = 'scale(0)';

        await wait(200);

        targets.forEach(c => { c.el.remove(); grid[c.r][c.c] = null; });
        if(rainbowCell && grid[rainbowCell.r][rainbowCell.c]) {
            rainbowCell.el.remove(); grid[rainbowCell.r][rainbowCell.c] = null;
        }
        score += targets.length * 2;
        updateUI();
    }

    function hasPossibleMoves() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (c < COLS - 1 && checkSwap(r, c, r, c+1)) return true;
                if (r < ROWS - 1 && checkSwap(r, c, r+1, c)) return true;
                if (grid[r][c] && grid[r][c].bonus) return true;
            }
        }
        return false;
    }

    function checkSwap(r1, c1, r2, c2) {
        if(!grid[r1][c1] || !grid[r2][c2]) return false;
        let t = grid[r1][c1].type; grid[r1][c1].type = grid[r2][c2].type; grid[r2][c2].type = t;
        let matches = findMatches().matched.length > 0;
        t = grid[r1][c1].type; grid[r1][c1].type = grid[r2][c2].type; grid[r2][c2].type = t;
        return matches;
    }

    async function shuffleBoard() {
        isBusy = true;
        let items = [];
        for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) if(grid[r][c]) items.push(grid[r][c].type);
        items.sort(() => Math.random() - 0.5);
        let i = 0;
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(grid[r][c]) {
                    grid[r][c].type = items[i++];

                    if(grid[r][c].bonus) {
                        // –Ø–∫—â–æ –º–∏ –ø–µ—Ä–µ–º—ñ—à—É—î–º–æ –±–æ–Ω—É—Å - –≤—ñ–Ω –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –±–æ–Ω—É—Å–æ–º –±–µ–∑ —Ç–∏–ø—É
                        grid[r][c].type = 'BONUS_ENTITY';
                    }

                    updateCellVisuals(grid[r][c]);
                    grid[r][c].el.classList.remove('new-spawn');
                    void grid[r][c].el.offsetWidth;
                    grid[r][c].el.classList.add('new-spawn');
                }
            }
        }
        msgEl.innerText = "";
        await wait(400);
        if (findMatches().matched.length > 0) {
            await processMatches(findMatches());
        } else if (!hasPossibleMoves()) {
             shuffleBoard();
        } else {
             isBusy = false;
        }
    }

    function endGame(win) {
        clearInterval(timerId); isBusy = true;
        setTimeout(() => {
            if(win) alert(`üéâ –ü–µ—Ä–µ–º–æ–≥–∞! –í–∏ –Ω–∞–±—Ä–∞–ª–∏ ${score} –æ—á–æ–∫!`);
            else alert(`‚è∞ –ß–∞—Å –≤–∏–π—à–æ–≤! –í–∞—à —Ä–∞—Ö—É–Ω–æ–∫: ${score}`);
            closeGame();
        }, 100);
    }

    function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
    init();
})();
</script>
{% endblock %}